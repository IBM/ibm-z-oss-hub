<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/2.3.1/list.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <style>
    pre {background-color: #eeeeee; display: inline-block; padding: 12px }
    img {height: 200px; width: auto;}
    .note {border: 1px solid #cccccc; padding: 10px;}
  </style>


</head>
<body>
<div style="bottom: 0; position: fixed; background-color: black; width: 100%; color: white; height: 25px;"><a href="./index.html" style="padding: 10px; color: white">Return to Image List</a></div>
<div class="container" style="padding-top: 30px; padding-bottom: 60px;">
<h1>postgres</h1>
<p/><img src="https://upload.wikimedia.org/wikipedia/commons/2/2e/Pg_logo.png" width=200 height=200 alt="postgres"><p/>
<span>PostgreSQL, often simply "Postgres", is an object-relational database management system (ORDBMS) with an emphasis on extensibility and standards-compliance. As a database server, its primary function is to store data, securely and supporting best practices, and retrieve it later. It can handle workloads ranging from small single-machine applications to large Internet-facing applications with many concurrent users. Recent versions also provide replication of the database itself for security and scalability.
</span>
<p/>
<span><em>See <a href="https://www.postgresql.org/">postgresql.org</a> for more information</em></span>
<p/>
<b>This image is built by IBM to run on the IBM Z architecture and is not affiliated with any other community that provides a version of this image.</b>
<p/>
<hr/>
<p/>
<b><span>License</span></b>
<p/>
View license information <a href="https://www.postgresql.org/about/licence/">here</a>
<p/>
As with all Docker images, these likely also contain other software which may be under other licenses (such as Bash, etc from the base distribution, along with any direct or indirect dependencies of the primary software being contained).
<p/>
As for any pre-built image usage, it is the image user's responsibility to ensure that any use of this image complies with any relevant licenses for all software contained within.
<p/>
<hr/>
<p/>
<b><span>Versions</span></b>
<p/>
Use the pull string below for the version of this image you require.



<table class="table table-striped table-bordered">
<td>11</td>

<td>docker pull icr.io/ibmz/postgres@sha256:d42be0d6091d73dbd3195d5daaed733f797411cb4f5bf08fbf1e8372573e6860</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2OmQ0MmJlMGQ2MDkxZDczZGJkMzE5NWQ1ZGFhZWQ3MzNmNzk3NDExY2I0ZjViZjA4ZmJmMWU4MzcyNTczZTY4NjAifQ==/issues" target="_blank">Vulnerability Report</a></td><td>10-28-2020</td></tr><td>12</td>

<td>docker pull icr.io/ibmz/postgres@sha256:cb9535f8be310ccac75a530aeb6f28c9a05aac21fff7e74ac78b36a4eaa7710a</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2OmNiOTUzNWY4YmUzMTBjY2FjNzVhNTMwYWViNmYyOGM5YTA1YWFjMjFmZmY3ZTc0YWM3OGIzNmE0ZWFhNzcxMGEifQ==/issues" target="_blank">Vulnerability Report</a></td><td>10-28-2020</td></tr><td>14 14-bullseye 14.3 14.3-bullseye bullseye</td>

<td>docker pull icr.io/ibmz/postgres@sha256:ba01e930088632be582da414ed1886a230a2ee812e3c0a8f88120ac52000e9e2</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2OmJhMDFlOTMwMDg4NjMyYmU1ODJkYTQxNGVkMTg4NmEyMzBhMmVlODEyZTNjMGE4Zjg4MTIwYWM1MjAwMGU5ZTIifQ==/issues" target="_blank">Vulnerability Report</a></td><td>06-10-2022</td></tr><td>14.0</td>

<td>docker pull icr.io/ibmz/postgres@sha256:96e4ec0afbd6280e0500652523cb0c93039b3b71bb4c34b091c26483b047f59c</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2Ojk2ZTRlYzBhZmJkNjI4MGUwNTAwNjUyNTIzY2IwYzkzMDM5YjNiNzFiYjRjMzRiMDkxYzI2NDgzYjA0N2Y1OWMifQ==/issues" target="_blank">Vulnerability Report</a></td><td>10-01-2021</td></tr><td>13</td>

<td>docker pull icr.io/ibmz/postgres@sha256:2cd6ef46ac4485c5cedf25165e2ed5252dc2ef6e720012526d9e87424732b766</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2OjJjZDZlZjQ2YWM0NDg1YzVjZWRmMjUxNjVlMmVkNTI1MmRjMmVmNmU3MjAwMTI1MjZkOWU4NzQyNDczMmI3NjYifQ==/issues" target="_blank">Vulnerability Report</a></td><td>10-28-2020</td></tr><td>14.2</td>

<td>docker pull icr.io/ibmz/postgres@sha256:2745ecc722f966a08cc1e551cf48ae490b9681e331f5f6cb9d2986410fe0ce80</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2OjI3NDVlY2M3MjJmOTY2YTA4Y2MxZTU1MWNmNDhhZTQ5MGI5NjgxZTMzMWY1ZjZjYjlkMjk4NjQxMGZlMGNlODAifQ==/issues" target="_blank">Vulnerability Report</a></td><td>02-17-2022</td></tr><td>10</td>

<td>docker pull icr.io/ibmz/postgres@sha256:0031e5c286c91baaa005560b2ea49fdd74a9c03f18c3930278d2d45b5f8c1d60</td>

<td><a href="https://cloud.ibm.com/registry/images/eyJyZXBvIjoiaWNyLmlvL2libXovcG9zdGdyZXMiLCJsb25nRGlnZXN0Ijoic2hhMjU2OjAwMzFlNWMyODZjOTFiYWFhMDA1NTYwYjJlYTQ5ZmRkNzRhOWMwM2YxOGMzOTMwMjc4ZDJkNDViNWY4YzFkNjAifQ==/issues" target="_blank">Vulnerability Report</a></td><td>10-28-2020</td></tr>
<thead>

<tr>

<th scope="col">Version</th>

<th scope="col">Pull String</th>

<th scope="col">Security (IBM Cloud)</th>

<th scope="col">Created</th>

</tr>

</thead>

<tbody>

<tr>

</tbody>

</table>

<b><h3>Usage Notes</h3></b>
<p/>


<h4>Create user defined network (useful for connecting to other services attached to the same network (e.g. Kibana)):</h4>

<br><p><pre><code>docker network create somenetwork</code></pre></p>

<h5>Start a postgres instance:</h5>

<br><p><pre><code>docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword 
        -d icr.io/ibmz/postgres:[version]</code></pre></p>

<p>The default postgres user and database are created in the entrypoint with initdb.</p>

<p>Note you can also use -u psql in your docker run statement to enter the container as user psql</p>
<h4>Environment Variables:</h4>

<p>The PostgreSQL image uses several environment variables which are easy to miss. The only variable required is POSTGRES_PASSWORD, the rest are optional.<p>

<p><em>Warning: the Docker specific variables will only have an effect if you start the container with a data directory that is empty; any pre-existing database will be left untouched on container startup.</em></p>

<br>
<h4>POSTGRES_PASSWORD:</h4>

<p>This environment variable is required for you to use the PostgreSQL image.</p>

<p>It must not be empty or undefined. This environment variable sets the superuser password for PostgreSQL. The default superuser is defined by the POSTGRES_USER environment variable.</p>

<p>Note 1: The PostgreSQL image sets up trust authentication locally so you may notice a password is not required when connecting from localhost (inside the same container). However, a password will be required if connecting from a different host/container.</p>

<p>Note 2: This variable defines the superuser password in the PostgreSQL instance, as set by the initdb script during initial container startup. It has no effect on the PGPASSWORD environment variable that may be used by the psql client at runtime, as described at https://www.postgresql.org/docs/10/static/libpq-envars.html. PGPASSWORD, if used, will be specified as a separate environment variable.</p>

<br>
<h4>POSTGRES_USER:</h4>

<p>This optional environment variable is used in conjunction with POSTGRES_PASSWORD to set a user and its password. This variable will create the specified user with superuser power and a database with the same name. If it is not specified, then the default user of postgres will be used.</p>

<p>Be aware that if this parameter is specified, PostgreSQL will still show The files belonging to this database system will be owned by user "postgres" during initialization. This refers to the Linux system user (from /etc/passwd in the image) that the postgres daemon runs as, and as such is unrelated to the POSTGRES_USER option. See the section titled "Arbitrary --user Notes" for more details.</p>

<br>
<h4>POSTGRES_DB:</h4>

<p>This optional environment variable can be used to define a different name for the default database that is created when the image is first started. If it is not specified, then the value of POSTGRES_USER will be used.</p>

<br>
<h4>POSTGRES_INITDB_ARGS:</h4>

<p>This optional environment variable can be used to send arguments to postgres initdb. The value is a space separated string of arguments as postgres initdb would expect them. This is useful for adding functionality like data page checksums: <br><p><pre><code>-e POSTGRES_INITDB_ARGS="--data-checksums".</code></pre></p></p>

<br>
<h4>POSTGRES_INITDB_WALDIR:</h4>

<p>This optional environment variable can be used to define another location for the Postgres transaction log. By default the transaction log is stored in a subdirectory of the main Postgres data folder (PGDATA). Sometimes it can be desireable to store the transaction log in a different directory which may be backed by storage with different performance or reliability characteristics.</p>

<p>Note: on PostgreSQL 9.x, this variable is POSTGRES_INITDB_XLOGDIR (reflecting the changed name of the --xlogdir flag to --waldir in PostgreSQL 10+).</span>

<br>
<h4>POSTGRES_HOST_AUTH_METHOD:</h4>

<p>This optional variable can be used to control the auth-method for host connections for all databases, all users, and all addresses. If unspecified then md5 password authentication is used. On an uninitialized database, this will populate pg_hba.conf via this approximate line:</p>

<p><code>echo "host all all all $POSTGRES_HOST_AUTH_METHOD" >> pg_hba.conf</code></p>

<p>See the PostgreSQL documentation on pg_hba.conf for more information about possible values and their meanings.</p>

<p>Note 1: It is not recommended to use trust since it allows anyone to connect without a password, even if one is set (like via <code>POSTGRES_PASSWORD</code>). For more information see the PostgreSQL documentation on Trust Authentication.</p>

<p>Note 2: If you set <code>POSTGRES_HOST_AUTH_METHOD</code> to trust, then <code>POSTGRES_PASSWORD</code> is not required.</p>

<br>
<h4>PGDATA:</h4>

<p>This optional variable can be used to define another location - like a subdirectory - for the database files. The default is <code>/var/lib/postgresql/data</code>. If the data volume you're using is a filesystem mountpoint (like with GCE persistent disks) or remote folder that cannot be chowned to the postgres user (like some NFS mounts), Postgres initdb recommends a subdirectory be created to contain the data.</p>

<p>On ZCX, we will need to create a volume instead, and mount said volume within the created container.</p>


For example:

<br><p><pre><code>docker volume create yourvol</code></pre></p>


<br><p><pre><code>docker run -d \
    --name some-postgres \
    -e POSTGRES_PASSWORD=mysecretpassword \
    -e PGDATA=/var/lib/postgresql/data/pgdata \
    -v {your_volume}:/var/lib/postgresql/data \
    icr.io/ibmz/postgres:xx</code></pre></p>


<p>This is an environment variable that is not Docker specific. Because the variable is used by the postgres server binary (see the PostgreSQL docs), the entrypoint script takes it into account.</p>


<h4>Docker Secrets:</h4>

<p>As an alternative to passing sensitive information via environment variables, _FILE may be appended to some of the previously listed environment variables.</p>

<p>This causes the initialization script to load the values for those variables from files present in the container.</p>

<p>In particular, this can be used to load passwords from Docker secrets stored in <code>/run/secrets/secret_name</code> files.
Again, it's important to note that the contents of this directory will be blank by default and that bind mounts do not work presently in ZCX.</p>

<p>Please place password/environmental values within a volume using docker cp, and mount said volume within the container.</p>

<p>Map this volume to the path <code>/run/secrets/name_of_file</code>.</p>

<b>EX:</b>

<br><p><pre><code>docker volume create psgrs</code></pre></p>
<br><p><pre><code>mkdir -p run/secrets</code></pre></p>

<p>then place any environmental values as their own named files within <code>/run/secrets/</code></p>

<p>We will point to this file during our docker run statement, and pass it as an environment variable to be used by postgres.</p>

<p>Now move the contents of <code>/run/secrets*</code> over to the volume you've created by using a temporary container to populate the volume.</p>

<p>Keep in mind that tail -f /dev/null can be replaced with any command that doesn't return an exit code.</p>

<br><p><pre><code>docker run -d --rm --name temp -v your_volume:/root/ icr.io/ibmz/alpine:3.12 tail -f /dev/null</code></pre></p>

<br><p><pre><code>docker cp run/. temp:/root</code></pre></p>

<br><p><pre><code>docker stop temp</code></pre></p>

<span>Then run the postgres container using this new volume to populate <code>/run/secrets</code> with the needed files to pass as environment variables.</span>

<span><br><p><pre><code>docker run --name some-postgres -v {your_volume}:/run/ \
    -e POSTGRES_PASSWORD_FILE=/run/secrets/<postgres_passwd_file> -d icr.io/ibmz/postgres:xx</code></pre></p></span>

<span>Currently, this is only supported for <code>POSTGRES_INITDB_ARGS</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_USER</code>, and <code>POSTGRES_DB</code>.</span>

<span>Where to Store Data</span>

<span>NOTE: On ZCX, it is recommended that you use Docker Volumes to maintain the data used by postgres:</span>

<span>Create a volume, create a data directory, mount this volume in a temporary container to fill with contents from host (/data/*). Content should persist.</span>

<br><p><pre><code>docker run -d --rm --name temp -v {your_volume}:/root/ icr.io/ibmz/alpine:3.12 tail -f /dev/null</code></pre></p>

<br><p><pre><code>docker cp data/. temp:/root</code></pre></p>

<br><p><pre><code>docker stop temp</code></pre></p>

<p>Start your postgres container like this:</p>

<br><p><pre><code>docker run --name some-postgres -v {your_volume}:/var/lib/postgresql/data \
         -e POSTGRES_PASSWORD=mysecretpassword -d icr.io/ibmz/postgres:xx</code></pre></p>

<p>The <code>-v your_volume:/var/lib/postgresql/data</code> part of the command mounts your (volume)data directory from the underlying host system as /var/lib/postgresql/data inside the container, where PostgreSQL by default will write its data files.
Initialization scripts</p>

<p>If you would like to do additional initialization in an image derived from this one, add one or more *.sql, *.sql.gz, or *.sh scripts under <code>/docker-entrypoint-initdb.d</code> (creating the directory if necessary). After the entrypoint calls initdb to create the default postgres user and database, it will run any *.sql files, run any executable *.sh scripts, and source any non-executable *.sh scripts found in that directory to do further initialization before starting the service.</span>

<p>Warning: scripts in /docker-entrypoint-initdb.d are only run if you start the container with a data directory that is empty; any pre-existing database will be left untouched on container startup. One common problem is that if one of your /docker-entrypoint-initdb.d scripts fails (which will cause the entrypoint script to exit) and your orchestrator restarts the container with the already initialized data directory, it will not continue on with your scripts.</span>

<p>For example, to add an additional user and database, add the following to <code>/docker-entrypoint-initdb.d/init-user-db.sh</code>:</p>

<br><p><pre><code>#!/bin/bash
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    CREATE USER docker;
    CREATE DATABASE docker;
    GRANT ALL PRIVILEGES ON DATABASE docker TO docker;
EOSQL</code></pre></p>

<p>These initialization files will be executed in sorted name order as defined by the current locale, which defaults to en_US.utf8. Any *.sql files will be executed by <code>POSTGRES_USER</code>, which defaults to the postgres superuser. It is recommended that any psql commands that are run inside of a *.sh script be executed as <code>POSTGRES_USER</code> by using the <code>--username "$POSTGRES_USER"</code> flag. This user will be able to connect without a password due to the presence of trust authentication for Unix socket connections made inside the container.
Arbitrary --user Notes</p>

<p>The main caveat to note is that postgres doesn't care what UID it runs as (as long as the owner of <code>/var/lib/postgresql/data</code> matches), but initdb does care (and needs the user to exist in <code>/etc/passwd</code>):</p>

<p><code>docker run -it --rm --user www-data -e POSTGRES_PASSWORD=mysecretpassword icr.io/ibmz/postgres:13</code></p>

<p>The files belonging to this database system will be owned by user <code>"www-data"</code>.</p>
<p><pre><code>docker run -it --rm --user 1000:1000 -e POSTGRES_PASSWORD=mysecretpassword \
        icr.io/ibmz/postgres:xx
initdb: could not look up effective user ID 1000: user does not exist</code></pre></p>

</div>
</body>
</html>
